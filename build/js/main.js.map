{"version":3,"sources":["webpack:///webpack/bootstrap cea6d89dff40aa04d1f8","webpack:///H:/htmlacademy/code_and_magick/160545-code-and-magick/src/main.js","webpack:///H:/htmlacademy/code_and_magick/160545-code-and-magick/src/form.js","webpack:///H:/htmlacademy/code_and_magick/160545-code-and-magick/src/game.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACtCA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,eAAc,WAAW;AACzB;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA,EAAC;;;;;;;ACzBD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,gBAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAC;;;;;;;AC/FD;;AAEA;AACA;AACA;AACA,aAAY;AACZ;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB,eAAc;AACd;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;;AAEA;AACA;AACA,cAAa,OAAO;AACpB,eAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,cAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;;AAEA,iBAAgB,QAAQ;AACxB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,QAAO;AACP;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,gBAAe,OAAO;AACtB,gBAAe,SAAS;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,QAAO;AACP,MAAK;;AAEL;AACA;AACA,gBAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA,gBAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,gBAAe,yBAAyB;AACxC,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB,kBAAkB;AACvC;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,gBAAe,yBAAyB;AACxC,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA,sBAAqB,cAAc;AACnC;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,0BAAyB,cAAc;AACvC;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,gBAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAO;;AAEP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,QAAO;;AAEP;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAkB;AAClB;AACA;AACA;AACA;AACA,sBAAqB,OAAO;AAC5B,uBAAsB;AACtB;AACA;AACA;AACA;AACA,cAAa;;AAEb;AACA;AACA;AACA,YAAW;;AAEX;AACA;AACA,sBAAqB,OAAO;AAC5B,uBAAsB;AACtB;AACA;AACA;AACA,YAAW;;AAEX;AACA;AACA,sBAAqB,OAAO;AAC5B,uBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,gBAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA,gBAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA,gBAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,EAAC","file":"main.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap cea6d89dff40aa04d1f8\n **/","'use strict';\r\n\r\nrequire('./form');\r\nrequire('./game');\r\n\r\n(function() {\r\n  var game = new window.Game(document.querySelector('.demo'));\r\n  game.initializeLevelAndStart();\r\n  game.setGameStatus(window.Game.Verdict.INTRO);\r\n\r\n  var formOpenButton = document.querySelector('.reviews-controls-new');\r\n\r\n  /** @param {MouseEvent} evt */\r\n  formOpenButton.onclick = function(evt) {\r\n    evt.preventDefault();\r\n\r\n    window.form.open(function() {\r\n      game.setGameStatus(window.Game.Verdict.PAUSE);\r\n      game.setDeactivated(true);\r\n    });\r\n  };\r\n\r\n  window.form.onClose = function() {\r\n    game.setDeactivated(false);\r\n  };\r\n})();\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** H:/htmlacademy/code_and_magick/160545-code-and-magick/src/main.js\n ** module id = 0\n ** module chunks = 0\n **/","'use strict';\r\n\r\nwindow.form = (function() {\r\n  var formContainer = document.querySelector('.overlay-container');\r\n  var formCloseButton = document.querySelector('.review-form-close');\r\n  var formSubmitButton = document.querySelector('.review-submit');\r\n  var formNameInput = document.querySelector('.review-form-field-name');\r\n  var formNameReminder = document.querySelector('.review-fields-name');\r\n  var formTextInput = document.querySelector('.review-form-field-text');\r\n  var formTextReminder = document.querySelector('.review-fields-text');\r\n  var formStars = document.querySelectorAll('.review-mark-label');\r\n\r\n  var form = {\r\n    onClose: null,\r\n\r\n    /**\r\n     * @param {Function} cb\r\n     */\r\n    open: function(cb) {\r\n      formContainer.classList.remove('invisible');\r\n      this.checkValidation();\r\n      cb();\r\n    },\r\n\r\n    close: function() {\r\n      formContainer.classList.add('invisible');\r\n\r\n      if (typeof this.onClose === 'function') {\r\n        this.onClose();\r\n      }\r\n    },\r\n\r\n    checkValidation: function() {\r\n      var isValidName = this.checkValidationName();\r\n      var isValidText = this.checkValidationText(this.getNumStars());\r\n      var isValid = isValidName && isValidText;\r\n      return isValid;\r\n    },\r\n\r\n    checkValidationName: function() {\r\n      var isValid = (formNameInput.value !== '');\r\n      this.setVisible(formNameReminder, !isValid);\r\n      return isValid;\r\n    },\r\n\r\n    checkValidationText: function(numStars) {\r\n      var isValid = (numStars >= 3 || formTextInput.value !== '');\r\n      this.setVisible(formTextReminder, !isValid);\r\n      return isValid;\r\n    },\r\n\r\n    setVisible: function(obj, value) {\r\n      if (value) {\r\n        obj.classList.remove('invisible');\r\n      } else {\r\n        obj.classList.add('invisible');\r\n      }\r\n    },\r\n\r\n    getNumStars: function() {\r\n      return document.querySelector('input[name=\"review-mark\"]:checked').value;\r\n    }\r\n  };\r\n\r\n\r\n  formCloseButton.onclick = function(evt) {\r\n    evt.preventDefault();\r\n    form.close();\r\n  };\r\n\r\n  formSubmitButton.onclick = function(evt) {\r\n    var isValid = form.checkValidation();\r\n    if (!isValid) {\r\n      evt.preventDefault();\r\n    }\r\n  };\r\n\r\n  formNameInput.oninput = function(evt) {\r\n    evt.preventDefault();\r\n    form.checkValidationName();\r\n  };\r\n\r\n  formTextInput.oninput = function(evt) {\r\n    evt.preventDefault();\r\n    form.checkValidationText();\r\n  };\r\n\r\n  for (var i = 0; i < formStars.length; i++) {\r\n    formStars[i].onclick = function() {\r\n      var numStars = this.control.value;\r\n      form.checkValidationText(numStars);\r\n    };\r\n  }\r\n\r\n  return form;\r\n})();\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** H:/htmlacademy/code_and_magick/160545-code-and-magick/src/form.js\n ** module id = 1\n ** module chunks = 0\n **/","'use strict';\r\n\r\nwindow.Game = (function() {\r\n  /**\r\n   * @const\r\n   * @type {number}\r\n   */\r\n  var HEIGHT = 300;\r\n\r\n  /**\r\n   * @const\r\n   * @type {number}\r\n   */\r\n  var WIDTH = 700;\r\n\r\n  /**\r\n   * ID уровней.\r\n   * @enum {number}\r\n   */\r\n  var Level = {\r\n    INTRO: 0,\r\n    MOVE_LEFT: 1,\r\n    MOVE_RIGHT: 2,\r\n    LEVITATE: 3,\r\n    HIT_THE_MARK: 4\r\n  };\r\n\r\n  /**\r\n   * Порядок прохождения уровней.\r\n   * @type {Array.<Level>}\r\n   */\r\n  var LevelSequence = [\r\n    Level.INTRO\r\n  ];\r\n\r\n  /**\r\n   * Начальный уровень.\r\n   * @type {Level}\r\n   */\r\n  var INITIAL_LEVEL = LevelSequence[0];\r\n\r\n  /**\r\n   * Допустимые виды объектов на карте.\r\n   * @enum {number}\r\n   */\r\n  var ObjectType = {\r\n    ME: 0,\r\n    FIREBALL: 1\r\n  };\r\n\r\n  /**\r\n   * Допустимые состояния объектов.\r\n   * @enum {number}\r\n   */\r\n  var ObjectState = {\r\n    OK: 0,\r\n    DISPOSED: 1\r\n  };\r\n\r\n  /**\r\n   * Коды направлений.\r\n   * @enum {number}\r\n   */\r\n  var Direction = {\r\n    NULL: 0,\r\n    LEFT: 1,\r\n    RIGHT: 2,\r\n    UP: 4,\r\n    DOWN: 8\r\n  };\r\n\r\n  /**\r\n   * Правила перерисовки объектов в зависимости от состояния игры.\r\n   * @type {Object.<ObjectType, function(Object, Object, number): Object>}\r\n   */\r\n  var ObjectsBehaviour = {};\r\n\r\n  /**\r\n   * Обновление движения мага. Движение мага зависит от нажатых в данный момент\r\n   * стрелок. Маг может двигаться одновременно по горизонтали и по вертикали.\r\n   * На движение мага влияет его пересечение с препятствиями.\r\n   * @param {Object} object\r\n   * @param {Object} state\r\n   * @param {number} timeframe\r\n   */\r\n  ObjectsBehaviour[ObjectType.ME] = function(object, state, timeframe) {\r\n    // Пока зажата стрелка вверх, маг сначала поднимается, а потом левитирует\r\n    // в воздухе на определенной высоте.\r\n    // NB! Сложность заключается в том, что поведение описано в координатах\r\n    // канваса, а не координатах, относительно нижней границы игры.\r\n    if (state.keysPressed.UP && object.y > 0) {\r\n      object.direction = object.direction & ~Direction.DOWN;\r\n      object.direction = object.direction | Direction.UP;\r\n      object.y -= object.speed * timeframe * 2;\r\n\r\n      if (object.y < 0) {\r\n        object.y = 0;\r\n      }\r\n    }\r\n\r\n    // Если стрелка вверх не зажата, а маг находится в воздухе, он плавно\r\n    // опускается на землю.\r\n    if (!state.keysPressed.UP) {\r\n      if (object.y < HEIGHT - object.height) {\r\n        object.direction = object.direction & ~Direction.UP;\r\n        object.direction = object.direction | Direction.DOWN;\r\n        object.y += object.speed * timeframe / 3;\r\n      } else {\r\n        object.Direction = object.direction & ~Direction.DOWN;\r\n      }\r\n    }\r\n\r\n    // Если зажата стрелка влево, маг перемещается влево.\r\n    if (state.keysPressed.LEFT) {\r\n      object.direction = object.direction & ~Direction.RIGHT;\r\n      object.direction = object.direction | Direction.LEFT;\r\n      object.x -= object.speed * timeframe;\r\n    }\r\n\r\n    // Если зажата стрелка вправо, маг перемещается вправо.\r\n    if (state.keysPressed.RIGHT) {\r\n      object.direction = object.direction & ~Direction.LEFT;\r\n      object.direction = object.direction | Direction.RIGHT;\r\n      object.x += object.speed * timeframe;\r\n    }\r\n\r\n    // Ограничения по перемещению по полю. Маг не может выйти за пределы поля.\r\n    if (object.y < 0) {\r\n      object.y = 0;\r\n      object.Direction = object.direction & ~Direction.DOWN;\r\n      object.Direction = object.direction & ~Direction.UP;\r\n    }\r\n\r\n    if (object.y > HEIGHT - object.height) {\r\n      object.y = HEIGHT - object.height;\r\n      object.Direction = object.direction & ~Direction.DOWN;\r\n      object.Direction = object.direction & ~Direction.UP;\r\n    }\r\n\r\n    if (object.x < 0) {\r\n      object.x = 0;\r\n    }\r\n\r\n    if (object.x > WIDTH - object.width) {\r\n      object.x = WIDTH - object.width;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Обновление движения файрбола. Файрбол выпускается в определенном направлении\r\n   * и после этого неуправляемо движется по прямой в заданном направлении. Если\r\n   * он пролетает весь экран насквозь, он исчезает.\r\n   * @param {Object} object\r\n   * @param {Object} state\r\n   * @param {number} timeframe\r\n   */\r\n  ObjectsBehaviour[ObjectType.FIREBALL] = function(object, state, timeframe) {\r\n    if (object.direction & Direction.LEFT) {\r\n      object.x -= object.speed * timeframe;\r\n    }\r\n\r\n    if (object.direction & Direction.RIGHT) {\r\n      object.x += object.speed * timeframe;\r\n    }\r\n\r\n    if (object.x < 0 || object.x > WIDTH) {\r\n      object.state = ObjectState.DISPOSED;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * ID возможных ответов функций, проверяющих успех прохождения уровня.\r\n   * CONTINUE говорит о том, что раунд не закончен и игру нужно продолжать,\r\n   * WIN о том, что раунд выигран, FAIL — о поражении. PAUSE о том, что игру\r\n   * нужно прервать.\r\n   * @enum {number}\r\n   */\r\n  var Verdict = {\r\n    CONTINUE: 0,\r\n    WIN: 1,\r\n    FAIL: 2,\r\n    PAUSE: 3,\r\n    INTRO: 4\r\n  };\r\n\r\n  /**\r\n   * Правила завершения уровня. Ключами служат ID уровней, значениями функции\r\n   * принимающие на вход состояние уровня и возвращающие true, если раунд\r\n   * можно завершать или false если нет.\r\n   * @type {Object.<Level, function(Object):boolean>}\r\n   */\r\n  var LevelsRules = {};\r\n\r\n  /**\r\n   * Уровень считается пройденным, если был выпущен файлболл и он улетел\r\n   * за экран.\r\n   * @param {Object} state\r\n   * @return {Verdict}\r\n   */\r\n  LevelsRules[Level.INTRO] = function(state) {\r\n    var fireballs = state.garbage.filter(function(object) {\r\n      return object.type === ObjectType.FIREBALL;\r\n    });\r\n\r\n    return fireballs.length ? Verdict.WIN : Verdict.CONTINUE;\r\n  };\r\n\r\n  /**\r\n   * Начальные условия для уровней.\r\n   * @enum {Object.<Level, function>}\r\n   */\r\n  var LevelsInitialize = {};\r\n\r\n  /**\r\n   * Первый уровень.\r\n   * @param {Object} state\r\n   * @return {Object}\r\n   */\r\n  LevelsInitialize[Level.INTRO] = function(state) {\r\n    state.objects.push(\r\n      // Установка персонажа в начальное положение. Он стоит в крайнем левом\r\n      // углу экрана, глядя вправо. Скорость перемещения персонажа на этом\r\n      // уровне равна 2px за кадр.\r\n      {\r\n        direction: Direction.RIGHT,\r\n        height: 84,\r\n        speed: 2,\r\n        sprite: 'img/wizard.gif',\r\n        spriteReversed: 'img/wizard-reversed.gif',\r\n        state: ObjectState.OK,\r\n        type: ObjectType.ME,\r\n        width: 61,\r\n        x: WIDTH / 3,\r\n        y: HEIGHT - 100\r\n      }\r\n    );\r\n\r\n    return state;\r\n  };\r\n\r\n  /**\r\n   * Конструктор объекта Game. Создает canvas, добавляет обработчики событий\r\n   * и показывает приветственный экран.\r\n   * @param {Element} container\r\n   * @constructor\r\n   */\r\n  var Game = function(container) {\r\n    this.container = container;\r\n    this.canvas = document.createElement('canvas');\r\n    this.canvas.width = container.clientWidth;\r\n    this.canvas.height = container.clientHeight;\r\n    this.container.appendChild(this.canvas);\r\n\r\n    this.ctx = this.canvas.getContext('2d');\r\n\r\n    this._onKeyDown = this._onKeyDown.bind(this);\r\n    this._onKeyUp = this._onKeyUp.bind(this);\r\n    this._pauseListener = this._pauseListener.bind(this);\r\n\r\n    this.setDeactivated(false);\r\n  };\r\n\r\n  Game.prototype = {\r\n    /**\r\n     * Текущий уровень игры.\r\n     * @type {Level}\r\n     */\r\n    level: INITIAL_LEVEL,\r\n\r\n    /** @param {boolean} deactivated */\r\n    setDeactivated: function(deactivated) {\r\n      if (this._deactivated === deactivated) {\r\n        return;\r\n      }\r\n\r\n      this._deactivated = deactivated;\r\n\r\n      if (deactivated) {\r\n        this._removeGameListeners();\r\n      } else {\r\n        this._initializeGameListeners();\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Состояние игры. Описывает местоположение всех объектов на игровой карте\r\n     * и время проведенное на уровне и в игре.\r\n     * @return {Object}\r\n     */\r\n    getInitialState: function() {\r\n      return {\r\n        // Статус игры. Если CONTINUE, то игра продолжается.\r\n        currentStatus: Verdict.CONTINUE,\r\n\r\n        // Объекты, удаленные на последнем кадре.\r\n        garbage: [],\r\n\r\n        // Время с момента отрисовки предыдущего кадра.\r\n        lastUpdated: null,\r\n\r\n        // Состояние нажатых клавиш.\r\n        keysPressed: {\r\n          ESC: false,\r\n          LEFT: false,\r\n          RIGHT: false,\r\n          SPACE: false,\r\n          UP: false\r\n        },\r\n\r\n        // Время начала прохождения уровня.\r\n        levelStartTime: null,\r\n\r\n        // Все объекты на карте.\r\n        objects: [],\r\n\r\n        // Время начала прохождения игры.\r\n        startTime: null\r\n      };\r\n    },\r\n\r\n    /**\r\n     * Начальные проверки и запуск текущего уровня.\r\n     * @param {Level=} level\r\n     * @param {boolean=} restart\r\n     */\r\n    initializeLevelAndStart: function(level, restart) {\r\n      level = typeof level === 'undefined' ? this.level : level;\r\n      restart = typeof restart === 'undefined' ? true : restart;\r\n\r\n      if (restart || !this.state) {\r\n        // При перезапуске уровня, происходит полная перезапись состояния\r\n        // игры из изначального состояния.\r\n        this.state = this.getInitialState();\r\n        this.state = LevelsInitialize[this.level](this.state);\r\n      } else {\r\n        // При продолжении уровня состояние сохраняется, кроме записи о том,\r\n        // что состояние уровня изменилось с паузы на продолжение игры.\r\n        this.state.currentStatus = Verdict.CONTINUE;\r\n      }\r\n\r\n      // Запись времени начала игры и времени начала уровня.\r\n      this.state.levelStartTime = Date.now();\r\n      if (!this.state.startTime) {\r\n        this.state.startTime = this.state.levelStartTime;\r\n      }\r\n\r\n      this._preloadImagesForLevel(function() {\r\n        // Предварительная отрисовка игрового экрана.\r\n        this.render();\r\n\r\n        // Установка обработчиков событий.\r\n        this._initializeGameListeners();\r\n\r\n        // Запуск игрового цикла.\r\n        this.update();\r\n      }.bind(this));\r\n    },\r\n\r\n    /**\r\n     * Временная остановка игры.\r\n     * @param {Verdict=} verdict\r\n     */\r\n    pauseLevel: function(verdict) {\r\n      if (verdict) {\r\n        this.state.currentStatus = verdict;\r\n      }\r\n\r\n      this.state.keysPressed.ESC = false;\r\n      this.state.lastUpdated = null;\r\n\r\n      this._removeGameListeners();\r\n      window.addEventListener('keydown', this._pauseListener);\r\n\r\n      this._drawPauseScreen();\r\n    },\r\n\r\n    /**\r\n     * Обработчик событий клавиатуры во время паузы.\r\n     * @param {KeyboardsEvent} evt\r\n     * @private\r\n     * @private\r\n     */\r\n    _pauseListener: function(evt) {\r\n      if (evt.keyCode === 32 && !this._deactivated) {\r\n        evt.preventDefault();\r\n        var needToRestartTheGame = this.state.currentStatus === Verdict.WIN ||\r\n            this.state.currentStatus === Verdict.FAIL;\r\n        this.initializeLevelAndStart(this.level, needToRestartTheGame);\r\n\r\n        window.removeEventListener('keydown', this._pauseListener);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Отрисовка экрана паузы.\r\n     */\r\n    _drawPauseScreen: function() {\r\n      var text;\r\n      switch (this.state.currentStatus) {\r\n        case Verdict.WIN:\r\n          console.log('you have won!');\r\n          text = 'You have won!\\nPress Space to restart';\r\n          break;\r\n        case Verdict.FAIL:\r\n          console.log('you have failed!');\r\n          text = 'You have failed!\\nPress Space to restart';\r\n          break;\r\n        case Verdict.PAUSE:\r\n          console.log('game is on pause!');\r\n          text = 'Game is on pause!\\nPress Space to resume';\r\n          break;\r\n        case Verdict.INTRO:\r\n          console.log('welcome to the game! Press Space to start');\r\n          text = 'Welcome to the game! Arrows can move. Shift can shoot. Don\\'t worry. Breathe deeply.\\nPress Space to start';\r\n          break;\r\n        default:\r\n          console.log('Warning: unknown currentStatus');\r\n          return;\r\n      }\r\n      var x = 310;\r\n      var y = 220;\r\n      this._drawSpeechBubble(this.ctx, text, x, y);\r\n    },\r\n\r\n    /**\r\n     * Нарисует облачко с текстом\r\n     * @param {CanvasRenderingContext2D} ctx\r\n     * @param {String} text\r\n     * @param {number} x\r\n     * @param {number} y\r\n    */\r\n    _drawSpeechBubble: function(ctx, text, x, y) {\r\n      var width = 276;\r\n      var deformation = 20;\r\n      var padding = 20;\r\n      // text\r\n      var textWidth = width - 2 * padding;\r\n      var textX = x + deformation + padding;\r\n      var textYBottom = y - deformation - padding + 0.25 * deformation;\r\n      ctx.save();\r\n      ctx.translate(textX, textYBottom);\r\n      var textHeight = this._drawCanvasText(text, textWidth);\r\n      ctx.restore();\r\n      // bubble\r\n      var height = textHeight + 2 * padding;\r\n      this._drawBubbleOnBack(ctx, x, y, width, height, deformation, '#FFFFFF');\r\n      this._drawBubbleOnBack(ctx, x + 10, y + 10, width, height, deformation, 'rgba(0, 0, 0, 0.7)');\r\n    },\r\n\r\n    /**\r\n    * Нарисует облачко по заданным параметрам на заднем слое canvas\r\n    */\r\n    _drawBubbleOnBack: function(ctx, x, y, width, height, deformation, fillStyle) {\r\n      ctx.save();\r\n      ctx.globalCompositeOperation = 'destination-over';\r\n      ctx.beginPath();\r\n      ctx.moveTo(x, y);\r\n      ctx.lineTo(x + deformation, y - deformation - height);\r\n      ctx.lineTo(x + deformation + width, y - deformation - height);\r\n      ctx.lineTo(x + deformation + width, y - deformation);\r\n      ctx.closePath();\r\n      ctx.fillStyle = fillStyle;\r\n      ctx.fill();\r\n      ctx.globalCompositeOperation = 'source-over';\r\n      ctx.restore();\r\n    },\r\n\r\n    /**\r\n     * Нарисует текст не шире width на canvas, вернет высоту текста\r\n     * !!! (0, 0) точка на canvas воспринимается как левая нижняя относительно текста\r\n     * @param {String} text\r\n     * @param {number} width\r\n    */\r\n    _drawCanvasText: function(text, width) {\r\n      var fontSize = 16;\r\n      this.ctx.textBaseline = 'hanging';\r\n      this.ctx.textAlign = 'left';\r\n      this.ctx.fillStyle = '#000000';\r\n      this.ctx.font = String(fontSize) + 'px PT Mono';\r\n      var lines = this._findCanvasTextLines(this.ctx, text, width);\r\n      var lineHeight = 1.25 * fontSize;\r\n      var textHeight = lines.length * lineHeight;\r\n      for (var i = 0; i < lines.length; i++) {\r\n        this.ctx.fillText(lines[i], 0, -textHeight + lineHeight * i);\r\n      }\r\n      return textHeight;\r\n    },\r\n\r\n    /**\r\n     * Разделит текст на строки для вывода на canvas\r\n     * !!! На canvas уже должны буть установлены параметры шрифта\r\n     * @param {CanvasRenderingContext2D} ctx\r\n     * @param {String} text\r\n     * @param {number} maxWidth\r\n    */\r\n    _findCanvasTextLines: function(ctx, text, maxWidth) {\r\n      var result = [];\r\n      var lines = text.split('\\n');\r\n      var numLines = lines.length;\r\n      for (var i = 0; i < numLines; i++) {\r\n        var line = lines[i];\r\n        var lineWidth = ctx.measureText(line).width;\r\n        if (lineWidth <= maxWidth) {\r\n          result.push(line);\r\n        } else {\r\n          var words = line.split(' ');\r\n          var numWords = words.length;\r\n          line = '';\r\n          for (var n = 0; n < numWords; n++) {\r\n            var testLine = line + words[n] + ' ';\r\n            var testWidth = ctx.measureText(testLine).width;\r\n            if (testWidth > maxWidth) {\r\n              result.push(line);\r\n              line = words[n] + ' ';\r\n            } else {\r\n              line = testLine;\r\n            }\r\n          }\r\n          if (line.length > 0) {\r\n            result.push(line);\r\n          }\r\n        }\r\n      }\r\n      return result;\r\n    },\r\n\r\n    /**\r\n     * Предзагрузка необходимых изображений для уровня.\r\n     * @param {function} callback\r\n     * @private\r\n     */\r\n    _preloadImagesForLevel: function(callback) {\r\n      if (typeof this._imagesArePreloaded === 'undefined') {\r\n        this._imagesArePreloaded = [];\r\n      }\r\n\r\n      if (this._imagesArePreloaded[this.level]) {\r\n        callback();\r\n        return;\r\n      }\r\n\r\n      var levelImages = [];\r\n      this.state.objects.forEach(function(object) {\r\n        levelImages.push(object.sprite);\r\n\r\n        if (object.spriteReversed) {\r\n          levelImages.push(object.spriteReversed);\r\n        }\r\n      });\r\n\r\n      var i = levelImages.length;\r\n      var imagesToGo = levelImages.length;\r\n\r\n      while (i-- > 0) {\r\n        var image = new Image();\r\n        image.src = levelImages[i];\r\n        image.onload = function() {\r\n          if (--imagesToGo === 0) {\r\n            this._imagesArePreloaded[this.level] = true;\r\n            callback();\r\n          }\r\n        }.bind(this);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Обновление статуса объектов на экране. Добавляет объекты, которые должны\r\n     * появиться, выполняет проверку поведения всех объектов и удаляет те, которые\r\n     * должны исчезнуть.\r\n     * @param {number} delta Время, прошеднее с отрисовки прошлого кадра.\r\n     */\r\n    updateObjects: function(delta) {\r\n      // Персонаж.\r\n      var me = this.state.objects.filter(function(object) {\r\n        return object.type === ObjectType.ME;\r\n      })[0];\r\n\r\n      // Добавляет на карту файрбол по нажатию на Shift.\r\n      if (this.state.keysPressed.SHIFT) {\r\n        this.state.objects.push({\r\n          direction: me.direction,\r\n          height: 24,\r\n          speed: 5,\r\n          sprite: 'img/fireball.gif',\r\n          type: ObjectType.FIREBALL,\r\n          width: 24,\r\n          x: me.direction & Direction.RIGHT ? me.x + me.width : me.x - 24,\r\n          y: me.y + me.height / 2\r\n        });\r\n\r\n        this.state.keysPressed.SHIFT = false;\r\n      }\r\n\r\n      this.state.garbage = [];\r\n\r\n      // Убирает в garbage не используемые на карте объекты.\r\n      var remainingObjects = this.state.objects.filter(function(object) {\r\n        ObjectsBehaviour[object.type](object, this.state, delta);\r\n\r\n        if (object.state === ObjectState.DISPOSED) {\r\n          this.state.garbage.push(object);\r\n          return false;\r\n        }\r\n\r\n        return true;\r\n      }, this);\r\n\r\n      this.state.objects = remainingObjects;\r\n    },\r\n\r\n    /**\r\n     * Проверка статуса текущего уровня.\r\n     */\r\n    checkStatus: function() {\r\n      // Нет нужны запускать проверку, нужно ли останавливать уровень, если\r\n      // заранее известно, что да.\r\n      if (this.state.currentStatus !== Verdict.CONTINUE) {\r\n        return;\r\n      }\r\n\r\n      if (!this.commonRules) {\r\n        /**\r\n         * Проверки, не зависящие от уровня, но влияющие на его состояние.\r\n         * @type {Array.<functions(Object):Verdict>}\r\n         */\r\n        this.commonRules = [\r\n          /**\r\n           * Если персонаж мертв, игра прекращается.\r\n           * @param {Object} state\r\n           * @return {Verdict}\r\n           */\r\n          function checkDeath(state) {\r\n            var me = state.objects.filter(function(object) {\r\n              return object.type === ObjectType.ME;\r\n            })[0];\r\n\r\n            return me.state === ObjectState.DISPOSED ?\r\n                Verdict.FAIL :\r\n                Verdict.CONTINUE;\r\n          },\r\n\r\n          /**\r\n           * Если нажата клавиша Esc игра ставится на паузу.\r\n           * @param {Object} state\r\n           * @return {Verdict}\r\n           */\r\n          function checkKeys(state) {\r\n            return state.keysPressed.ESC ? Verdict.PAUSE : Verdict.CONTINUE;\r\n          },\r\n\r\n          /**\r\n           * Игра прекращается если игрок продолжает играть в нее два часа подряд.\r\n           * @param {Object} state\r\n           * @return {Verdict}\r\n           */\r\n          function checkTime(state) {\r\n            return Date.now() - state.startTime > 3 * 60 * 1000 ?\r\n                Verdict.FAIL :\r\n                Verdict.CONTINUE;\r\n          }\r\n        ];\r\n      }\r\n\r\n      // Проверка всех правил влияющих на уровень. Запускаем цикл проверок\r\n      // по всем универсальным проверкам и проверкам конкретного уровня.\r\n      // Цикл продолжается до тех пор, пока какая-либо из проверок не вернет\r\n      // любое другое состояние кроме CONTINUE или пока не пройдут все\r\n      // проверки. После этого состояние сохраняется.\r\n      var allChecks = this.commonRules.concat(LevelsRules[this.level]);\r\n      var currentCheck = Verdict.CONTINUE;\r\n      var currentRule;\r\n\r\n      while (currentCheck === Verdict.CONTINUE && allChecks.length) {\r\n        currentRule = allChecks.shift();\r\n        currentCheck = currentRule(this.state);\r\n      }\r\n\r\n      this.state.currentStatus = currentCheck;\r\n    },\r\n\r\n    /**\r\n     * Принудительная установка состояния игры. Используется для изменения\r\n     * состояния игры от внешних условий, например, когда необходимо остановить\r\n     * игру, если она находится вне области видимости и установить вводный\r\n     * экран.\r\n     * @param {Verdict} status\r\n     */\r\n    setGameStatus: function(status) {\r\n      if (this.state.currentStatus !== status) {\r\n        this.state.currentStatus = status;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Отрисовка всех объектов на экране.\r\n     */\r\n    render: function() {\r\n      // Удаление всех отрисованных на странице элементов.\r\n      this.ctx.clearRect(0, 0, WIDTH, HEIGHT);\r\n\r\n      // Выставление всех элементов, оставшихся в this.state.objects согласно\r\n      // их координатам и направлению.\r\n      this.state.objects.forEach(function(object) {\r\n        if (object.sprite) {\r\n          var image = new Image(object.width, object.height);\r\n          image.src = (object.spriteReversed && object.direction & Direction.LEFT) ?\r\n              object.spriteReversed :\r\n              object.sprite;\r\n          this.ctx.drawImage(image, object.x, object.y, object.width, object.height);\r\n        }\r\n      }, this);\r\n    },\r\n\r\n    /**\r\n     * Основной игровой цикл. Сначала проверяет состояние всех объектов игры\r\n     * и обновляет их согласно правилам их поведения, а затем запускает\r\n     * проверку текущего раунда. Рекурсивно продолжается до тех пор, пока\r\n     * проверка не вернет состояние FAIL, WIN или PAUSE.\r\n     */\r\n    update: function() {\r\n      if (!this.state.lastUpdated) {\r\n        this.state.lastUpdated = Date.now();\r\n      }\r\n\r\n      var delta = (Date.now() - this.state.lastUpdated) / 10;\r\n      this.updateObjects(delta);\r\n      this.checkStatus();\r\n\r\n      switch (this.state.currentStatus) {\r\n        case Verdict.CONTINUE:\r\n          this.state.lastUpdated = Date.now();\r\n          this.render();\r\n          requestAnimationFrame(function() {\r\n            this.update();\r\n          }.bind(this));\r\n          break;\r\n\r\n        case Verdict.WIN:\r\n        case Verdict.FAIL:\r\n        case Verdict.PAUSE:\r\n        case Verdict.INTRO:\r\n          this.pauseLevel();\r\n          break;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @param {KeyboardEvent} evt [description]\r\n     * @private\r\n     */\r\n    _onKeyDown: function(evt) {\r\n      switch (evt.keyCode) {\r\n        case 37:\r\n          this.state.keysPressed.LEFT = true;\r\n          break;\r\n        case 39:\r\n          this.state.keysPressed.RIGHT = true;\r\n          break;\r\n        case 38:\r\n          this.state.keysPressed.UP = true;\r\n          break;\r\n        case 27:\r\n          this.state.keysPressed.ESC = true;\r\n          break;\r\n      }\r\n\r\n      if (evt.shiftKey) {\r\n        this.state.keysPressed.SHIFT = true;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @param {KeyboardEvent} evt [description]\r\n     * @private\r\n     */\r\n    _onKeyUp: function(evt) {\r\n      switch (evt.keyCode) {\r\n        case 37:\r\n          this.state.keysPressed.LEFT = false;\r\n          break;\r\n        case 39:\r\n          this.state.keysPressed.RIGHT = false;\r\n          break;\r\n        case 38:\r\n          this.state.keysPressed.UP = false;\r\n          break;\r\n        case 27:\r\n          this.state.keysPressed.ESC = false;\r\n          break;\r\n      }\r\n\r\n      if (evt.shiftKey) {\r\n        this.state.keysPressed.SHIFT = false;\r\n      }\r\n    },\r\n\r\n    /** @private */\r\n    _initializeGameListeners: function() {\r\n      window.addEventListener('keydown', this._onKeyDown);\r\n      window.addEventListener('keyup', this._onKeyUp);\r\n    },\r\n\r\n    /** @private */\r\n    _removeGameListeners: function() {\r\n      window.removeEventListener('keydown', this._onKeyDown);\r\n      window.removeEventListener('keyup', this._onKeyUp);\r\n    }\r\n  };\r\n\r\n  Game.Verdict = Verdict;\r\n\r\n  return Game;\r\n})();\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** H:/htmlacademy/code_and_magick/160545-code-and-magick/src/game.js\n ** module id = 2\n ** module chunks = 0\n **/"],"sourceRoot":""}